THERE_BE_DRAGONS_HERE
Literal expected
12 September 2025 10:30:12.787233 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

OCSyntaxErrorNotice(OCNotice)>>signalError
	Receiver: OCSyntaxErrorNotice(29:Literal expected)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		messageText: 	nil
		node: 	OCParseErrorNode(#)


OpalCompiler>>checkNotice:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		aNotice: 	OCSyntaxErrorNotice(29:Literal expected)
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { # faces };
		package: 'dice'
		source: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
		n: 	OCSyntaxErrorNotice(29:Literal expected)
		check: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { # faces };
		package: 'dice'
		source: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(OCSyntaxErrorNotice(29:Literal expected))
	Arguments and temporary variables: 
		aBlock: 	[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(OCSyntaxErrorNotice(29:Literal expected) nil nil nil nil ni[..]
		firstIndex: 	1
		lastIndex: 	1


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { # faces };
		package: 'dice'
		source: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { # faces };
		package: 'dice'
		source: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { # faces };
		package: 'dice'
		source: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OCCodeReparator>>defineClassOrTrait:definitionString:
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		aSymbol: 	#Die
		aString: 	'Object << #Die
	layout: FixedLayout;
	traits: {};
	slots: {};
	sh[..]
		classBinding: 	nil
		result: 	nil
		definitionString: 	'Object << #Die
	
	slots: { # faces  };
	
	package: ''dice'''
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(540163328)


OCCodeReparator>>defineClass:
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		classSymbol: 	#Die
		class: 	DICETEST
		classDefinition: 	'Object << #Die
	layout: FixedLayout;
	traits: {};
	slots:[..]
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(540163328)


[ self defineClass: name asSymbol ] in [
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(24 to: 26)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(540163328)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defineClass: name asSymbol ]
	Arguments and temporary variables: 
		exception: 	Abort
		handlerAction: 	[ self openMenu ]
	Receiver's instance variables: 
		outerContext: 	[
				[ self defineClass: name asSymbol ]
					on: Abort
				[..]
		compiledBlock: 	a CompiledBlock: [ self defineClass: name asSymbol ]
		numArgs: 	0
		receiver: 	an OCCodeReparator


[
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(24 to: 26)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(540163328)


OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(24 to: 26)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(540163328)


OpalCompiler>>checkNotice:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		aNotice: 	OCUndeclaredVariableNotice(24:Undeclared variable)
		reparator: 	an OCCodeReparator
		res: 	nil
	Receiver's instance variables: 
		ast: 	testintok

	self assert: Die new faces equals: 6
		source: 	'testintok
self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		priorMethod: 	nil


[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
		n: 	OCUndeclaredVariableNotice(24:Undeclared variable)
		check: 	nil
	Receiver's instance variables: 
		ast: 	testintok

	self assert: Die new faces equals: 6
		source: 	'testintok
self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		priorMethod: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(OCUndeclaredVariableNotice(24:Undeclared variable))
	Arguments and temporary variables: 
		aBlock: 	[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(OCUndeclaredVariableNotice(24:Undeclared variable) nil nil [..]
		firstIndex: 	1
		lastIndex: 	1


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
	Receiver's instance variables: 
		ast: 	testintok

	self assert: Die new faces equals: 6
		source: 	'testintok
self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		priorMethod: 	nil


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		ast: 	testintok

	self assert: Die new faces equals: 6
		source: 	'testintok
self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		priorMethod: 	nil


OpalCompiler>>install
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		class: 	DICETEST
		method: 	nil
		logSource: 	nil
	Receiver's instance variables: 
		ast: 	testintok

	self assert: Die new faces equals: 6
		source: 	'testintok
self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		priorMethod: 	nil


DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'testintok
self assert: Die new faces equals: 6'
		protocol: 	nil
		changeStamp: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
		logSource: 	true
		method: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'testintok
self assert: Die new faces equals: 6'
		protocol: 	nil
		changeStamp: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


DICETEST class(ClassDescription)>>compile:classified:notifying:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'testintok
self assert: Die new faces equals: 6'
		protcol: 	nil
		requestor: 	a RubScrolledTextMorph(540163328)
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


ClyMethodCreationToolMorph>>applyChanges
	Receiver: a ClyMethodCreationToolMorph(39276288)
	Arguments and temporary variables: 
		newMethod: 	nil
		selector: 	nil
		selectedClass: 	DICETEST
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(540163328) a ClyStatusBarMorph(9[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (1049817344) [other:  (kmDispatcher -> a CmdKMD[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(555255296)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(972671744)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(540163328)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(39276288)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(540163328) a ClyStatusBarMorph(9[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (1049817344) [other:  (kmDispatcher -> a CmdKMD[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(555255296)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(972671744)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(540163328)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err |
				  textModel setText: self editingText.
				  te[..]
	Receiver's instance variables: 
		outerContext: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self chan[..]
		compiledBlock: 	a CompiledBlock: [
		  self changesAreAboutApply.
		  applie[..]
		numArgs: 	0
		receiver: 	a ClyMethodCreationToolMorph(39276288)


[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(39276288)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(540163328) a ClyStatusBarMorph(9[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (1049817344) [other:  (kmDispatcher -> a CmdKMD[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(555255296)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(972671744)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(540163328)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  app[..]
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false]
		handler: 	[ applyingChanges := false]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAc[..]
		compiledBlock: 	a CompiledBlock: [
		  textMorph hasUnacceptedEdits: true.
	[..]
		numArgs: 	0
		receiver: 	a ClyMethodCreationToolMorph(39276288)


ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyMethodCreationToolMorph(39276288)
	Arguments and temporary variables: 
		aBlock: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAre[..]
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(540163328) a ClyStatusBarMorph(9[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (1049817344) [other:  (kmDispatcher -> a CmdKMD[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(555255296)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(972671744)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(540163328)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(39276288)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(540163328) a ClyStatusBarMorph(9[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (1049817344) [other:  (kmDispatcher -> a CmdKMD[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(555255296)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(972671744)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(540163328)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(39276288))
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(39276288)


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(39276288))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(39276288)


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(39276288))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(39276288)


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
	Receiver: an AnnouncementSubscription (a ClyMethodCreationToolMorph(39276288) subscribes to RubT[..]
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		action: 	MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(39276288))
		subscriber: 	a ClyMethodCreationToolMorph(39276288)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyMethodCreationToolMorph(3927628[..]


[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		onDoCtx: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyMethodCreationToolMorph(3927628[..]



--- The full stack ---
OCSyntaxErrorNotice(OCNotice)>>signalError
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>evaluate
OCCodeReparator>>defineClassOrTrait:definitionString:
OCCodeReparator>>defineClass:
[ self defineClass: name asSymbol ] in [
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
FullBlockClosure(BlockClosure)>>on:do:
[
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
OCCodeReparator>>openMenu
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>install
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:
DICETEST class(ClassDescription)>>compile:classified:notifying:
ClyMethodCreationToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cascade message expected
12 September 2025 10:33:12.797621 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

OCSyntaxErrorNotice(OCNotice)>>signalError
	Receiver: OCSyntaxErrorNotice(39:Cascade message expected)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		messageText: 	nil
		node: 	OCParseErrorNode()


OpalCompiler>>checkNotice:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		aNotice: 	OCSyntaxErrorNotice(39:Cascade message expected)
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { #faces };
		
		source: 	'Object << #Die

	slots: {  #faces  };
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
		n: 	OCSyntaxErrorNotice(39:Cascade message expected)
		check: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { #faces };
		
		source: 	'Object << #Die

	slots: {  #faces  };
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(OCSyntaxErrorNotice(39:Cascade message expected))
	Arguments and temporary variables: 
		aBlock: 	[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(OCSyntaxErrorNotice(39:Cascade message expected) nil nil ni[..]
		firstIndex: 	1
		lastIndex: 	1


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { #faces };
		
		source: 	'Object << #Die

	slots: {  #faces  };
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { #faces };
		
		source: 	'Object << #Die

	slots: {  #faces  };
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	(Object << #Die)
		slots: { #faces };
		
		source: 	'Object << #Die

	slots: {  #faces  };
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	nil
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	nil
		priorMethod: 	nil


OCCodeReparator>>defineClassOrTrait:definitionString:
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		aSymbol: 	#Die
		aString: 	'Object << #Die
	layout: FixedLayout;
	traits: {};
	slots: {};
	sh[..]
		classBinding: 	nil
		result: 	nil
		definitionString: 	'Object << #Die

	slots: {  #faces  };
'
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(107320064)


OCCodeReparator>>defineClass:
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		classSymbol: 	#Die
		class: 	DICETEST
		classDefinition: 	'Object << #Die
	layout: FixedLayout;
	traits: {};
	slots:[..]
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(107320064)


[ self defineClass: name asSymbol ] in [
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(26 to: 28)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(107320064)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defineClass: name asSymbol ]
	Arguments and temporary variables: 
		exception: 	Abort
		handlerAction: 	[ self openMenu ]
	Receiver's instance variables: 
		outerContext: 	[
				[ self defineClass: name asSymbol ]
					on: Abort
				[..]
		compiledBlock: 	a CompiledBlock: [ self defineClass: name asSymbol ]
		numArgs: 	0
		receiver: 	an OCCodeReparator


[
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(26 to: 28)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(107320064)


OCCodeReparator>>openMenu
	Receiver: an OCCodeReparator
	Arguments and temporary variables: 
		alternatives: 	an OrderedCollection(#DiffDelete #DiskFileAttributesTestsReso[..]
		labels: 	an OrderedCollection('Leave variable undeclared' 'Define new class'[..]
		actions: 	an OrderedCollection([ ^ nil ] [
				[ self defineClass: name asSy[..]
		lines: 	an OrderedCollection(1 4 14)
		caption: 	'Unknown variable: Die please correct, or cancel:'
		choice: 	2
		name: 	#Die
		interval: 	(26 to: 28)
	Receiver's instance variables: 
		node: 	OCVariableNode(Die)
		requestor: 	a RubScrolledTextMorph(107320064)


OpalCompiler>>checkNotice:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		aNotice: 	OCUndeclaredVariableNotice(26:Undeclared variable)
		reparator: 	an OCCodeReparator
		res: 	nil
	Receiver's instance variables: 
		ast: 	Testintok

	self assert: Die new faces equals: 6
		source: 	'Testintok

	self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		priorMethod: 	nil


[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
		n: 	OCUndeclaredVariableNotice(26:Undeclared variable)
		check: 	nil
	Receiver's instance variables: 
		ast: 	Testintok

	self assert: Die new faces equals: 6
		source: 	'Testintok

	self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		priorMethod: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(OCUndeclaredVariableNotice(26:Undeclared variable))
	Arguments and temporary variables: 
		aBlock: 	[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(OCUndeclaredVariableNotice(26:Undeclared variable) nil nil [..]
		firstIndex: 	1
		lastIndex: 	1


OpalCompiler>>parse
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		parser: 	an OCParser
	Receiver's instance variables: 
		ast: 	Testintok

	self assert: Die new faces equals: 6
		source: 	'Testintok

	self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		priorMethod: 	nil


OpalCompiler>>compile
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		ast: 	Testintok

	self assert: Die new faces equals: 6
		source: 	'Testintok

	self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		priorMethod: 	nil


OpalCompiler>>install
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		class: 	DICETEST
		method: 	nil
		logSource: 	nil
	Receiver's instance variables: 
		ast: 	Testintok

	self assert: Die new faces equals: 6
		source: 	'Testintok

	self assert: Die new faces equals: 6'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ ^ nil ]
		logged: 	true
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		priorMethod: 	nil


DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'Testintok

	self assert: Die new faces equals: 6'
		protocol: 	nil
		changeStamp: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
		logSource: 	true
		method: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'Testintok

	self assert: Die new faces equals: 6'
		protocol: 	nil
		changeStamp: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


DICETEST class(ClassDescription)>>compile:classified:notifying:
	Receiver: DICETEST
	Arguments and temporary variables: 
		sourceCode: 	'Testintok

	self assert: Die new faces equals: 6'
		protcol: 	nil
		requestor: 	a RubScrolledTextMorph(107320064)
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary()
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


ClyMethodCreationToolMorph>>applyChanges
	Receiver: a ClyMethodCreationToolMorph(917137664)
	Arguments and temporary variables: 
		newMethod: 	nil
		selector: 	nil
		selectedClass: 	DICETEST
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(107320064) a ClyStatusBarMorph(4[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (917447168) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(603304448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(402866944)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(107320064)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(917137664)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(107320064) a ClyStatusBarMorph(4[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (917447168) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(603304448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(402866944)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(107320064)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err |
				  textModel setText: self editingText.
				  te[..]
	Receiver's instance variables: 
		outerContext: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self chan[..]
		compiledBlock: 	a CompiledBlock: [
		  self changesAreAboutApply.
		  applie[..]
		numArgs: 	0
		receiver: 	a ClyMethodCreationToolMorph(917137664)


[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(917137664)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(107320064) a ClyStatusBarMorph(4[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (917447168) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(603304448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(402866944)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(107320064)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  app[..]
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false]
		handler: 	[ applyingChanges := false]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAc[..]
		compiledBlock: 	a CompiledBlock: [
		  textMorph hasUnacceptedEdits: true.
	[..]
		numArgs: 	0
		receiver: 	a ClyMethodCreationToolMorph(917137664)


ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyMethodCreationToolMorph(917137664)
	Arguments and temporary variables: 
		aBlock: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAre[..]
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(107320064) a ClyStatusBarMorph(4[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (917447168) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(603304448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(402866944)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(107320064)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCreationToolMorph(917137664)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(61.0@398.0) corner: (966.0@628.0)
		owner: 	a PanelMorph(239952128)
		submorphs: 	an Array(a RubScrolledTextMorph(107320064) a ClyStatusBarMorph(4[..]
		fullBounds: 	(61@398) corner: (966@628)
		color: 	Color transparent
		extension: 	a MorphExtension (917447168) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(550214400)
		context: 	a ClyFullBrowserMethodGroupContext
		decorators: 	an OrderedCollection()
		containerTab: 	a ClyNotebookPageMorph(603304448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(402866944)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(107320064)
		changesCancelRequested: 	false
		applyingChanges: 	true
		ast: 	methodSelectorAndArgumentNames
	"comment stating purpose of instance-s[..]
		methodProtocol: 	nil
		extendingPackage: 	nil
		targetClasses: 	{DICETEST}
		methodClass: 	DICETEST


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(917137664))
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(917137664)


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(917137664))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(917137664)


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(917137664))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyMethodCreationToolMorph(917137664)


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
	Receiver: an AnnouncementSubscription (a ClyMethodCreationToolMorph(917137664) subscribes to Rub[..]
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		action: 	MessageSend(#changesAccepted -> a ClyMethodCreationToolMorph(917137[..]
		subscriber: 	a ClyMethodCreationToolMorph(917137664)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyMethodCreationToolMorph(9171376[..]


[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		onDoCtx: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyMethodCreationToolMorph(9171376[..]



--- The full stack ---
OCSyntaxErrorNotice(OCNotice)>>signalError
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>evaluate
OCCodeReparator>>defineClassOrTrait:definitionString:
OCCodeReparator>>defineClass:
[ self defineClass: name asSymbol ] in [
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
FullBlockClosure(BlockClosure)>>on:do:
[
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
OCCodeReparator>>openMenu
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>install
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:
DICETEST class(ClassDescription)>>compile:classified:notifying:
ClyMethodCreationToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: Die >> #Testintok
12 September 2025 11:01:57.033651 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

Die(Object)>>doesNotUnderstand: #Testintok
	Receiver: a Die
	Arguments and temporary variables: 
		aMessage: 	Testintok
		exception: 	Instance of Die did not understand #Testintok
		resumeValue: 	nil
	Receiver's instance variables: 
		faces: 	6


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	Die new Testintok
		source: 	'Die  new Testintok '
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Die  new Testintok '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 19) ]
		text: 	an ObservableValueHolder[ 'Die  new Testintok ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Die  new Testintok '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 19) ]
		text: 	an ObservableValueHolder[ 'Die  new Testintok ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Die  new Testintok '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Die  new Testintok '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in [delaySemaphore wait] in Delay>>wait
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in [delaySemaphore wait] in Delay>>wait
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in [delaySemaphore wait] in Delay>>wait
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in [delaySemaphore wait] in Delay>>wait
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory



--- The full stack ---
Die(Object)>>doesNotUnderstand: #Testintok
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
TextEditorDialogWindow(SystemWindow)>>openModal
DarkBlueTheme(UITheme)>>textEditorIn:text:title:entryText:entryHeight:
MorphicUIManager>>multiLineRequest:initialAnswer:answerHeight:
OCCodeReparator>>defineClassOrTrait:definitionString:
OCCodeReparator>>defineClass:
[ self defineClass: name asSymbol ] in [
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
FullBlockClosure(BlockClosure)>>on:do:
[
				[ self defineClass: name asSymbol ]
					on: Abort
					do: [ self openMenu ] ] in OCCodeReparator>>openMenu
OCCodeReparator>>openMenu
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>install
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
DICETEST class(ClassDescription)>>compile:classified:withStamp:notifying:
DICETEST class(ClassDescription)>>compile:classified:notifying:
ClyMethodCreationToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: DICETEST class >> #run
12 September 2025 11:04:23.138746 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

DICETEST class(Object)>>doesNotUnderstand: #run
	Receiver: DICETEST
	Arguments and temporary variables: 
		aMessage: 	run
		exception: 	Instance of DICETEST class did not understand #run
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#Testintok->DICETEST>>#Testintok )
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (as yet unclassified) - 1 selector(s))
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST run
		source: 	'DICETEST run'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'DICETEST run'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'DICETEST run'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory



--- The full stack ---
DICETEST class(Object)>>doesNotUnderstand: #run
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: DICETEST class >> #run
12 September 2025 11:04:37.665506 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

DICETEST class(Object)>>doesNotUnderstand: #run
	Receiver: DICETEST
	Arguments and temporary variables: 
		aMessage: 	run
		exception: 	Instance of DICETEST class did not understand #run
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#Testintok->DICETEST>>#Testintok )
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (as yet unclassified) - 1 selector(s))
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST run
		source: 	'DICETEST run.'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST run.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 13) ]
		text: 	an ObservableValueHolder[ 'DICETEST run.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST run.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 13) ]
		text: 	an ObservableValueHolder[ 'DICETEST run.' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'DICETEST run.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'DICETEST run.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory



--- The full stack ---
DICETEST class(Object)>>doesNotUnderstand: #run
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: Die >> #faces
12 September 2025 11:05:36.223562 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

Die(Object)>>doesNotUnderstand: #faces
	Receiver: a Die
	Arguments and temporary variables: 
		aMessage: 	faces
		exception: 	Instance of Die did not understand #faces
		resumeValue: 	nil
	Receiver's instance variables: 
		faces: 	6


DICETEST>>Testintok
	Receiver: DICETEST
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	nil
		expectedFails: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST new Testintok
		source: 	'DICETEST new Testintok '
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST new Testintok '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 23) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST new Testintok '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 23) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'DICETEST new Testintok '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'DICETEST new Testintok '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(662315520)
		secondArg: 	a RubEditingArea(662315520)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(662315520)
		category: 	a KMCategory
		morph: 	a RubEditingArea(662315520)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(662315520)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Die(Object)>>doesNotUnderstand: #faces
DICETEST>>Testintok
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: DICETEST >> #DICETEST
12 September 2025 11:14:41.761006 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

DICETEST(Object)>>doesNotUnderstand: #DICETEST
	Receiver: DICETEST
	Arguments and temporary variables: 
		aMessage: 	DICETEST
		exception: 	Instance of DICETEST did not understand #DICETEST
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	nil
		expectedFails: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST new Testintok DICETEST new testRolling
		source: 	'DICETEST new Testintok 
DICETEST new testRolling '
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST new Testintok 
DICETEST new testRolling '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 49) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok 
DICETEST new testR[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST new Testintok 
DICETEST new testRolling '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 49) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok 
DICETEST new testR[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'DICETEST new Testintok 
DICETEST new testRolling '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'DICETEST new Testintok 
DICETEST new testRolling '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(841214976)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(841214976)
		directKeymaps: 	a KMCategory



--- The full stack ---
DICETEST(Object)>>doesNotUnderstand: #DICETEST
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: Die class >> #withFaces:
12 September 2025 11:16:58.207129 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

Die class(Object)>>doesNotUnderstand: #withFaces:
	Receiver: Die
	Arguments and temporary variables: 
		aMessage: 	withFaces: 20
		exception: 	Instance of Die class did not understand #withFaces:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#faces->Die>>#faces #faces:->Die>>#faces: #i[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 1 selector(s) Protocol (act[..]
		subclasses: 	nil
		name: 	#Die
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


DICETEST>>testCreationIsOk
	Receiver: DICETEST
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	nil
		expectedFails: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST new
		testRolling;
		testCreationIsOk
		source: 	'DICETEST new testRolling ; testCreationIsOk 
'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST new testRolling ; testCreationIsOk 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (26 to: 70) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok .
DICETEST new test[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST new testRolling ; testCreationIsOk 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (26 to: 70) ]
		text: 	an ObservableValueHolder[ 'DICETEST new Testintok .
DICETEST new test[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'DICETEST new testRolling ; testCreationIsOk 
'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'DICETEST new testRolling ; testCreationIsOk 
'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(841214976)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Die class(Object)>>doesNotUnderstand: #withFaces:
DICETEST>>testCreationIsOk
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: DICETEST class >> #run
12 September 2025 11:47:27.033699 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

DICETEST class(Object)>>doesNotUnderstand: #run
	Receiver: DICETEST
	Arguments and temporary variables: 
		aMessage: 	run
		exception: 	Instance of DICETEST class did not understand #run
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#Testintok->DICETEST>>#Testintok #testCreati[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (as yet unclassified) - 1 selector(s) Protocol[..]
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST run
		source: 	'DICETEST run'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Playground' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]
		loading: 	false


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Playground' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]
		loading: 	false


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it all'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it all)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#go
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
		aButtonClass new
			label: specCommand name;
			help: specCommand description;
			in: [ :button | 
				specCommand hasIcon
					ifTrue: [ button icon: specCommand icon ] ];
			action: [ specCommand execute ];
			enabled: specCommand canBeExecuted;
			yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it all)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it all)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#go
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
		aButtonClass new
			label: specCommand na[..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it all)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319807232))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319807232)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		event: 	[(25.0@23.0) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 1356872 nil]
		all: 	an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(7677[..]
		m: 	a SpToolbarButtonMorph(319807232)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(767753472) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(767753472) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 1356872 nil]
		all: 	an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(7677[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 1356872 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(25.0@23.0) mouseUp 1356872 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319807232)
	Receiver's instance variables: 
		timeStamp: 	1356872
		source: 	a HandMorph(291751936)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(25.0@23.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 1356872 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1032@322) corner: (1048@338)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@322) mouseUp 1356872 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(291751936)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(1032@322) corner: (1048@338)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@322) mouseUp 1356872 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1032@322) corner: (1048@338)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@322) mouseUp 1356872 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(1032@322) corner: (1048@338)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@322) mouseUp 1356872 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
		evt: 	[(1032@322) mouseUp 1356872 nil]
	Receiver's instance variables: 
		bounds: 	(1032@322) corner: (1048@338)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@322) mouseUp 1356872 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1032@322) mouseUp 1356872 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(392766976) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1349590
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(449565952)))
		lastAlarmTime: 	1356854
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1349590
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(449565952)))
		lastAlarmTime: 	1356854
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		handler: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (hands) - 12 selector(s) Protocol (alarms) - 5[..]
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	88020798
		packageTag: 	a PackageTag(Worlds)


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
DICETEST class(Object)>>doesNotUnderstand: #run
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
		aButtonClass new
			label: specCommand name;
			help: specCommand description;
			in: [ :button | 
				specCommand hasIcon
					ifTrue: [ button icon: specCommand icon ] ];
			action: [ specCommand execute ];
			enabled: specCommand canBeExecuted;
			yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: DICETEST class >> #run
12 September 2025 11:47:33.405431 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

DICETEST class(Object)>>doesNotUnderstand: #run
	Receiver: DICETEST
	Arguments and temporary variables: 
		aMessage: 	run
		exception: 	Instance of DICETEST class did not understand #run
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#Testintok->DICETEST>>#Testintok #testCreati[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (as yet unclassified) - 1 selector(s) Protocol[..]
		subclasses: 	nil
		name: 	#DICETEST
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	DICETEST run
		source: 	'DICETEST run'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'DICETEST run'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 12) ]
		text: 	an ObservableValueHolder[ 'DICETEST run' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Playground' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]
		loading: 	false


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Playground' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]
		loading: 	false


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it all'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it all)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#go
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
		aButtonClass new
			label: specCommand name;
			help: specCommand description;
			in: [ :button | 
				specCommand hasIcon
					ifTrue: [ button icon: specCommand icon ] ];
			action: [ specCommand execute ];
			enabled: specCommand canBeExecuted;
			yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it all)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it all)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#go
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
		aButtonClass new
			label: specCommand na[..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it all)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319807232))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319807232)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		event: 	[(25.0@30.0) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		evt: 	[(25.0@30.0) mouseUp 1363254 nil]
		all: 	an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(7677[..]
		m: 	a SpToolbarButtonMorph(319807232)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(767753472) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(767753472) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		evt: 	[(25.0@30.0) mouseUp 1363254 nil]
		all: 	an Array(a SpToolbarButtonMorph(319807232) a SpToolbarButtonMorph(7677[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@30.0) mouseUp 1363254 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(25.0@30.0) mouseUp 1363254 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319807232)
	Receiver's instance variables: 
		timeStamp: 	1363254
		source: 	a HandMorph(291751936)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(25.0@30.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@30.0) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319807232)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@30.0) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(302123008)
		submorphs: 	an Array(an AlignmentMorph(246657792))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (102036480) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it all'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(480377856)'Do it all'
		iconMorph: 	an ImageMorph(162770944)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(25.0@30.0) mouseUp 1363254 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1032@329) corner: (1048@345)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	(1032@329) corner: (1048@345)
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@329) mouseUp 1363254 nil]
		targetOffset: 	(25.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(291751936)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(25.0@30.0) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(1032@329) corner: (1048@345)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	(1032@329) corner: (1048@345)
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@329) mouseUp 1363254 nil]
		targetOffset: 	(25.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
		focusHolder: 	a SpToolbarButtonMorph(319807232)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1032@329) corner: (1048@345)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	(1032@329) corner: (1048@345)
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@329) mouseUp 1363254 nil]
		targetOffset: 	(25.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(1032@329) corner: (1048@345)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	(1032@329) corner: (1048@345)
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@329) mouseUp 1363254 nil]
		targetOffset: 	(25.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
		evt: 	[(1032@329) mouseUp 1363254 nil]
	Receiver's instance variables: 
		bounds: 	(1032@329) corner: (1048@345)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	(1032@329) corner: (1048@345)
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(841214976)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1032@329) mouseUp 1363254 nil]
		targetOffset: 	(25.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1032@329) mouseUp 1363254 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(392766976) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1349590
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(449565952)))
		lastAlarmTime: 	1363236
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1349590
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(449565952)))
		lastAlarmTime: 	1363236
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(502844672) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	(0@0) corner: (1920@1014)
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		handler: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (hands) - 12 selector(s) Protocol (alarms) - 5[..]
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	88020798
		packageTag: 	a PackageTag(Worlds)


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
DICETEST class(Object)>>doesNotUnderstand: #run
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
		aButtonClass new
			label: specCommand name;
			help: specCommand description;
			in: [ :button | 
				specCommand hasIcon
					ifTrue: [ button icon: specCommand icon ] ];
			action: [ specCommand execute ];
			enabled: specCommand canBeExecuted;
			yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: SmallInteger >> #d20
15 September 2025 5:29:38.585529 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #d20
	Receiver: 2
	Arguments and temporary variables: 
		aMessage: 	d20
		exception: 	Instance of SmallInteger did not understand #d20
		resumeValue: 	nil
	Receiver's instance variables: 
2

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	2 d20 dicenumber
		source: 	'(2 d20) dicenumber'
		compilationContext: 	an OCCompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(2 d20) dicenumber'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 18) ]
		text: 	an ObservableValueHolder[ '(2 d20) dicenumber' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(2 d20) dicenumber'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ a SpCommandGroup ]
		internalActionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 18) ]
		text: 	an ObservableValueHolder[ '(2 d20) dicenumber' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ nil ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(2 d20) dicenumber'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(2 d20) dicenumber'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
		aButtonClass new
			label: specCom[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	7


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	72356110
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(841214976)
		secondArg: 	a RubEditingArea(841214976)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	17
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(841214976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(841214976)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(841214976)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavigation[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphCtrlNavi[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphCtrlNavigation) a KMCategoryBindin[..]
		morph: 	a RubEditingArea(841214976)
		directKeymaps: 	a KMCategory



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #d20
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self refreshStyling ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		| sequence |
		sequence := KMBuffer uniqueInstance buffer copy.
		targetToDispatch dispatch: sequence.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
		"Let's try to match this sequence of events again.
		This time ignoring any repeated events."
		sequence removeAllSuchThat: [ :ev | ev isRepeat ].
		sequence isNotEmpty ifTrue: [
			targetToDispatch dispatch: sequence.
			aKeyboardEvent wasHandled ifTrue: [ ^self ] ]
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
{localDirectory}/iceberg/c3p_my_count
15 September 2025 5:49:16.889325 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 96760dc5-9df8-0d00-b4b2-3fa60be5cca3 Aug 13 2025
v10.3.8+0.a7c8a0b - Commit: a7c8a0b - Date: 2025-08-12 19:03:31 +0200

Image: Pharo13.1.0SNAPSHOT [Build information: Pharo-13.1.0+SNAPSHOT.build.697.sha.af10a2ce70915e5076b7c9664f7851b9f7d95376 (64 Bit)]

StFileSystemModel>>currentDirectory:
	Receiver: a StFileSystemModel
	Arguments and temporary variables: 
		aFileReference: 	{localDirectory}/iceberg/c3p_my_count
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	nil
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		currentDirectory: 	{imageDirectory}
		history: 	a ConfigurableHistoryIterator


StDirectoryNavigationSystemPresenter(StFileBrowserAbstractPresenter)>>currentDirectory:
	Receiver: a StDirectoryNavigationSystemPresenter
	Arguments and temporary variables: 
		aFileReference: 	{localDirectory}/iceberg/c3p_my_count
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a StOpenDirectoryPresenter
		adapter: 	nil
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		model: 	a StFileSystemModel
		nameText: 	a SpTextInputFieldPresenter
		filtersDropList: 	a SpDropListPresenter
		filter: 	a StAllFilter
		previewer: 	nil
		nextButton: 	a SpButtonPresenter
		previousButton: 	a SpButtonPresenter
		notebookPreviewer: 	a StNoteBookPreviewerPresenter
		fileReferenceTable: 	a SpTablePresenter
		configButton: 	a SpButtonPresenter
		pathBreadcrumbPresenter: 	a StPathBreadcrumbPresenter
		newFolderButton: 	a SpButtonPresenter
		showPreview: 	nil


StDirectoryNavigationSystemPresenter(StFileNavigationSystemPresenter)>>updateWidgetWithFileReference:
	Receiver: a StDirectoryNavigationSystemPresenter
	Arguments and temporary variables: 
		aFileReference: 	{localDirectory}/iceberg/c3p_my_count
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	a StOpenDirectoryPresenter
		adapter: 	nil
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		model: 	a StFileSystemModel
		nameText: 	a SpTextInputFieldPresenter
		filtersDropList: 	a SpDropListPresenter
		filter: 	a StAllFilter
		previewer: 	nil
		nextButton: 	a SpButtonPresenter
		previousButton: 	a SpButtonPresenter
		notebookPreviewer: 	a StNoteBookPreviewerPresenter
		fileReferenceTable: 	a SpTablePresenter
		configButton: 	a SpButtonPresenter
		pathBreadcrumbPresenter: 	a StPathBreadcrumbPresenter
		newFolderButton: 	a SpButtonPresenter
		showPreview: 	nil


StOpenDirectoryPresenter(StFileSystemPresenter)>>openFolder:
	Receiver: a StOpenDirectoryPresenter
	Arguments and temporary variables: 
		aFileReference: 	{localDirectory}/iceberg/c3p_my_count
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	nil
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Select Directory To Open' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		model: 	a StFileSystemModel
		treeNavigationSystem: 	a StDirectoryTreePresenter
		fileNavigationSystem: 	a StDirectoryNavigationSystemPresenter
		bookmarksTreeTable: 	a SpTreeTablePresenter
		title: 	nil
		okAction: 	[ :fileReference | fileReference ]
		filter: 	nil


IceTipDirectoryPresenter>>chooseReference
	Receiver: an IceTipDirectoryPresenter
	Arguments and temporary variables: 
		reference: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipNewRepositoryPanel
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		locationInput: 	a SpTextInputFieldPresenter
		chooseButton: 	a SpButtonPresenter
		chooseTitle: 	'Choose local repository'
		chooseBlock: 	nil
		keptLocation: 	File @ /home/m1ipint/jingyi.huang.etu/Pharo/images/hjy2/pharo[..]


IceTipDirectoryPresenter(IceTipLocationPresenter)>>choose
	Receiver: an IceTipDirectoryPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipNewRepositoryPanel
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		locationInput: 	a SpTextInputFieldPresenter
		chooseButton: 	a SpButtonPresenter
		chooseTitle: 	'Choose local repository'
		chooseBlock: 	nil
		keptLocation: 	File @ /home/m1ipint/jingyi.huang.etu/Pharo/images/hjy2/pharo[..]


[ self choose ] in IceTipDirectoryPresenter(IceTipLocationPresenter)>>initializePresenters
	Receiver: an IceTipDirectoryPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipNewRepositoryPanel
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Unnamed Window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		locationInput: 	a SpTextInputFieldPresenter
		chooseButton: 	a SpButtonPresenter
		chooseTitle: 	'Choose local repository'
		chooseBlock: 	nil
		keptLocation: 	File @ /home/m1ipint/jingyi.huang.etu/Pharo/images/hjy2/pharo[..]


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipDirectoryPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		properties: 	a SmallDictionary()
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#('small')
		userActionGroup: 	an ObservableValueHolder[ nil ]
		internalActionGroup: 	nil
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		label: 	an ObservableValueHolder[ '' ]
		action: 	an ObservableValueHolder[ [ self choose ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(266169856))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(266169856)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		event: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		evt: 	[(1492@503) mouseUp 2207116 nil]
		all: 	an Array(a SpPluggableButtonMorph(266169856))
		m: 	a SpPluggableButtonMorph(266169856)
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(266169856))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(266169856))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		evt: 	[(1492@503) mouseUp 2207116 nil]
		all: 	an Array(a SpPluggableButtonMorph(266169856))
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1492@503) mouseUp 2207116 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(266169856)
	Receiver's instance variables: 
		timeStamp: 	2207116
		source: 	a HandMorph(291751936)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1492@503)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(266169856)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1481.0@489.0) corner: (1505.0@513.0)
		owner: 	a Morph(59716864)
		submorphs: 	an Array(an AlignmentMorph(414896128))
		fullBounds: 	nil
		color: 	(Color r: 0.22678396871945258 g: 0.2727272727272727 b: 0.37047898338[..]
		extension: 	a MorphExtension (107117824) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(75027456)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(75027456)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
		focusHolder: 	a SpPluggableButtonMorph(266169856)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(1492@503) mouseUp 2207116 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1492@503) corner: (1508@519)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(266169856)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1492@503) mouseUp 2207116 nil]
		targetOffset: 	(11.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(291751936)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(662938624) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
		focusHolder: 	a SpPluggableButtonMorph(266169856)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(392766976) [world]
		transformedEvent: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1492@503) corner: (1508@519)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(266169856)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1492@503) mouseUp 2207116 nil]
		targetOffset: 	(11.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
		focusHolder: 	a SpPluggableButtonMorph(266169856)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1492@503) corner: (1508@519)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(266169856)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1492@503) mouseUp 2207116 nil]
		targetOffset: 	(11.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1492@503) corner: (1508@519)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(266169856)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1492@503) mouseUp 2207116 nil]
		targetOffset: 	(11.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(291751936)
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
		evt: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		bounds: 	(1492@503) corner: (1508@519)
		owner: 	a WorldMorph(392766976) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (1062693888)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(266169856)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1492@503) mouseUp 2207116 nil]
		targetOffset: 	(11.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1492@503) mouseUp 2207116 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(392766976) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2003807
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2207106
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(662938624) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(392766976) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(291751936))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2003807
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2207106
		activeHand: 	a HandMorph(291751936)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1014)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(662938624) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(392766976) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1014)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(662938624) a TaskbarMorph(761613056) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.14858260019550343 g: 0.19648093841642228 b: 0.2199413489[..]
		extension: 	a MorphExtension (543116288) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		zoomFactor: 	1


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		handler: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (hands) - 12 selector(s) Protocol (alarms) - 5[..]
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	88020798
		packageTag: 	a PackageTag(Worlds)


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65548
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (operations) - 1 selector(s) Protocol (structu[..]
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemEnvironment(lots of globals)
		commentSourcePointer: 	87973514
		packageTag: 	a PackageTag(Worlds)
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	a StThreadSafeTranscript


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
StFileSystemModel>>currentDirectory:
StDirectoryNavigationSystemPresenter(StFileBrowserAbstractPresenter)>>currentDirectory:
StDirectoryNavigationSystemPresenter(StFileNavigationSystemPresenter)>>updateWidgetWithFileReference:
StOpenDirectoryPresenter(StFileSystemPresenter)>>openFolder:
IceTipDirectoryPresenter>>chooseReference
IceTipDirectoryPresenter(IceTipLocationPresenter)>>choose
[ self choose ] in IceTipDirectoryPresenter(IceTipLocationPresenter)>>initializePresenters
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

